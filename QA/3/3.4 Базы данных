Реляционная база данных — это тип базы данных, в которой данные организованы в таблицы, и эти таблицы связаны на основе данных, общих для каждой 
из них. Эта структура позволяет выполнять гибкие сложные запросы одновременно ко многим таблицам.
Структура реляционной базы данных
Реляционная база данных состоит из нескольких ключевых компонентов:
- таблицы. Это строительные блоки реляционной базы данных. Каждая таблица содержит данные об определенном объекте, таком как клиенты или продукты;
- поля(столбец). Это различные категории данных в каждой таблице, такие как «имя» или «электронная почта»;
- записи(строка). Это отдельные записи в таблице. Каждая запись включает уникальный ключ, известный как первичный ключ, который идентифицирует эту запись;
- отношения. Это связи между таблицами, установленные с помощью общих данных, известных как внешние ключи.
Pеляционные базы данных организуют данные в таблицы, нереляционные базы данных(NoSQL) не полагаются на табличную структуру и используют различные модели данных,
включая документ, график, ключ-значение и широкий столбец.
Реляционные базы данных лучше всего подходят для обработки структурированных данных и сложных запросов. Нереляционные базы данных лучше подходят для 
обработки больших объемов разнообразных, быстро меняющихся данных.

Команды 
mysql -u root -p
SHOW DATABASES;
CREATE DATABASE name;
DROP DATABASE name;
USE name;
show tables;
CREATE TABLE teacher(
       -> id INT AUTO_INCREMENT PRIMARY KEY,
       -> surname VARCHAR(255) NOT NULL
       -> );
show columns FROM teacher;
CREATE TABLE lesson(
    -> id INT AUTO_INCREMENT PRIMARY KEY,
    -> name VARCHAR(255) NOT NULL,
    -> teacher_id INT NOT NULL,
    -> FOREIGN KEY (teacher_id) references teacher(id)
    -> );
INSERT INTO teacher (surname) values ("Иванов");
SELECT * FROM teacher; - получить все данные из таблицы
SELECT DISTINCT surname FROM teacher; - толлько уникальтные значения из surname
SELECT * FROM teacher WHERE id = 1; - id >< 3 и т.д
SELECT * FROM teacher WHERE surname = "Петров";
SELECT * FROM teacher LIMIT 5;
SELECT id AS 'Идентификатор', surname AS 'Фамилия' FROM teacher; - временное перименование полей(ALTER TABLE постоянное)
SELECT * FROM teacher ORDER BY surname; - сортировка по фамилии
SELECT * FROM teacher ORDER BY id DESC; - сортировка по id в обратном порядке
ALTER TABLE teacher ADD age INT; - добавили колонку age в таблицу
UPDATE teacher SET age = 20 where id=1; - установили возраст 20 для айди 1
SELECT * FROM teacher WHERE surname LIKE "%ов"; - поиск по таблице любых слов с окончанием ов
SELECT * FROM teacher WHERE surname LIKE "п%ов"; найдет только начинается на п и окончаввается на ов
SELECT * FROM teacher WHERE id > 3 AND age < 46; логическая фильтрация OR или
SELECT * FROM teacher WHERE NOT id = 2; - исключить айди 2
SELECT * FROM teacher WHERE NOT id BETWEEN 2 and 5;
DELETE FROM teacher WHERE id = 8;
SELECT teacher.surname, lesson.name FROM teacher INNER JOIN lesson ON teacher.id = lesson.teacher_id;
INNER JOIN только совпадения из обеих таблиц.
LEFT OUTER JOIN все записи из левой таблицы, совпадения из правой, NULL для отсутствующих.
RIGHT OUTER JOIN все записи из правой таблицы, совпадения из левой, NULL для отсутствующих.
SELECT * FROM teacher UNION SELECT * FROM lesson; вертикальное обьединение UNION
SELECT AVG(age) FROM teacher; - возвращает средний возраст
SELECT MAX(age), MIN(age) FROM teacher;
SELECT SUM(age) FROM teacher;
INSERT INTO teacher (surname, age) VALUES ("Пупкин", 25), ("шишкин", 30); - добавление в табилцу
SELECT age, COUNT(age) FROM teacher GROUP BY age;



